/*
 * SonarQube Scanner for Gradle
 * Copyright (C) 2015-2025 SonarSource
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
 */
package org.sonarqube.gradle

import org.gradle.testkit.runner.GradleRunner
import org.gradle.testkit.runner.TaskOutcome
import spock.lang.IgnoreIf
import spock.lang.Specification
import spock.lang.TempDir

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardCopyOption

import static java.util.Objects.nonNull
import static org.assertj.core.api.Assertions.assertThat
import static org.gradle.testkit.runner.TaskOutcome.SUCCESS

class FunctionalTests extends Specification {
    String gradleVersion = "8.14.2"

    @TempDir
    Path projectDir
    Path settingsFile
    Path buildFile
    Path outFile

    def setup() {
        settingsFile = projectDir.resolve('settings.gradle')
        buildFile = projectDir.resolve('build.gradle')
        projectDir.resolve('integrationTests').toFile().mkdir()
        projectDir.resolve('integrationTests').resolve("run-all.sh") << "# a test script file"
        projectDir.resolve('test-license.sh') << "# a test script file"
        outFile = projectDir.resolve('out.properties')
        configureJacocoGradleTestkitPlugin(projectDir)
    }

    /**
     * Copy gradle.properties from resources to the test project to enable JaCoCo coverage.
     * This file is generated by the pl.droidsondroid.gradle.testkit.jacoco plugin.
     * See https://github.com/koral--/jacoco-gradle-testkit-plugin
     * @param dir the root of the test project
     */
    static def configureJacocoGradleTestkitPlugin(Path dir) {
        InputStream is = FunctionalTests.class.getClassLoader().getResourceAsStream('testkit-gradle.properties')
        Files.copy(is, dir.resolve('gradle.properties'), StandardCopyOption.REPLACE_EXISTING)
    }

    def "'java' project"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'org.sonarqube'
            id 'java'
        }
        """

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props.containsKey("sonar.java.jdkHome")
    }

    def "no jdkHome, source and target for non 'java' projects"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        !props.containsKey("sonar.java.jdkHome")
        !props.containsKey("sonar.java.source")
        !props.containsKey("sonar.java.target")
    }

    def "set jdkHome, source and target for 'java' projects from global toolchains"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        java {
          toolchain {
            languageVersion = JavaLanguageVersion.of(8)
          }
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        new File(props."sonar.java.jdkHome").exists()
        "${props."sonar.java.jdkHome"}${File.separator}bin${File.separator}java -version".execute()
          .err.text.contains("\"1.8.")
        def expectedJavaVersion = isGradle7OrLower(gradleVersion) ? '8' : '1.8'
        props."sonar.java.source" == expectedJavaVersion
        props."sonar.java.target" == expectedJavaVersion
    }

    def "set java release version"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        compileJava {
          options.release = 10
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.java.source" == '10'
        props."sonar.java.target" == '10'
    }

    def "set java release version with compiler arguments"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        compileJava {
          options.compilerArgs.addAll(['--release', '10'])
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        def expectedJavaVersion = isGradle7OrLower(gradleVersion) ? '10' : '21'
        props."sonar.java.source" == expectedJavaVersion
        props."sonar.java.target" == expectedJavaVersion
    }

    def "warn if using deprecated sonarqube task"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
            plugins {
                id 'org.sonarqube'
            }
            """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        result.output.contains("Task 'sonarqube' is deprecated. Use 'sonar' instead.")
    }

    def "set jdkHome, source and target for 'java' projects from task toolchains"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        compileJava {
          javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(8)
          }
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '--info', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.output.contains('Heterogeneous compiler configuration has been detected. Using compiler configuration from task: \'compileJava\'')
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        new File(props."sonar.java.jdkHome").exists()
        "${props."sonar.java.jdkHome"}${File.separator}bin${File.separator}java -version".execute()
          .err.text.contains("\"1.8.")

        def expectedJavaVersion = isGradle7OrLower(gradleVersion) ? '8' : '1.8'
        props."sonar.java.source" == expectedJavaVersion
        props."sonar.java.target" == expectedJavaVersion
    }

    def "log execution context"() {
        given:
        settingsFile << "rootProject.name = 'java-task-output-logs'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .withEnvironment(Map.of("GRADLE_OPTS", "-Dfoo=bar"))
          .forwardOutput()
          .withArguments('sonarqube', '--info', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        nonNull(
          assertThat(result.output)
            .containsPattern('org.sonarqube Gradle plugin \\d+\\.\\d+')
            .containsPattern('Java \\d+')
            .contains('(64-bit)')
            .contains('GRADLE_OPTS=-Dfoo=bar')
        )
    }

    def "log execution context even when sonar.skip is true"() {
        given:
        settingsFile << "rootProject.name = 'java-task-output-logs'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '--info', '-Dsonar.skip=true')
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        nonNull(
          assertThat(result.output)
            .contains('org.sonarqube Gradle plugin')
        )
    }

    // https://docs.gradle.org/6.6/release-notes.html#javacompile-release
    def "set jdkHome, source and target for 'java' projects from task release"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        compileJava {
          options.release = 8
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.java.source" == '8'
        props."sonar.java.target" == '8'
        // sonar.java.jdkHome will be the runtime JDK used to run Gradle, so we can't really assert its particular value
        // just check that it points to a valid path
        new File(props."sonar.java.jdkHome").exists()
        props."sonar.java.enablePreview" == "false"
    }

    def "enable preview without JDK toolchain"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        compileJava {
          options.compilerArgs.addAll("--enable-preview")
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.java.enablePreview" == "true"
    }

    def "enable preview with JDK toolchain"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        compileJava {
          javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(8)
          }
          options.compilerArgs.addAll("--enable-preview")
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '--info', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonarqube").outcome == SUCCESS
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.java.enablePreview" == "true"
    }

    def "don't crash if compiler arg isn't String"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        compileJava {
          options.compilerArgs = [
            file("/")
          ]
        }
        """

        when:
        GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonarqube', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()


        then:
        noExceptionThrown()
    }

    def "scan all is enabled"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments('sonar', '--info',
            '-Dsonar.gradle.scanAll=true',
            '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonar").outcome == SUCCESS

        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.gradle.scanAll" == "true"
        result.output.contains("Parameter sonar.gradle.scanAll is enabled. The scanner will attempt to collect additional sources.")

        var mainSources = ((String) props."sonar.sources").split(",")
        mainSources.size() == 3
        var projectPath = projectDir.toFile().getCanonicalPath() + File.separator
        mainSources[0].endsWith("""${projectPath}build.gradle""")
        mainSources[1].endsWith("""${projectPath}gradle.properties""")
        mainSources[2].endsWith("""${projectPath}settings.gradle""")

        var testSources = ((String) props."sonar.tests").split(",")
        testSources.size() == 2
        testSources[0].endsWith("""${projectPath}integrationTests${File.separator}run-all.sh""")
        testSources[1].endsWith("""${projectPath}test-license.sh""")
    }

    def "scan all is enabled but not applied because of overridden properties on the command line"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        var arguments = ['sonar', '--info',
                         '-Dsonar.gradle.scanAll=true',
                         sonarSourcesOverride != null ? '-Dsonar.sources=' + sonarSourcesOverride : null,
                         sonarTestsOverride != null ? '-Dsonar.tests=' + sonarTestsOverride : null,
                         '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath()]
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments(arguments.stream().filter { it != null }.toList())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonar").outcome == SUCCESS

        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.gradle.scanAll" == "true"
        result.output.contains("Parameter sonar.gradle.scanAll is enabled. The scanner will attempt to collect additional sources.")
        result.output.contains("Parameter sonar.gradle.scanAll is enabled but the scanner will not collect additional sources because sonar.sources or sonar.tests has been overridden.")

        where:
        sonarSourcesOverride | sonarTestsOverride
        "src"                | null
        null                 | "test"
        "src"                | "test"
    }

    def "scan all is enabled but not applied because of overridden properties in build configuration"() {
        given:
        var sonarSourcesProperty = sonarSourcesOverride ? "property 'sonar.sources', '$sonarSourcesOverride'" : ""
        var sonarTestsProperty = sonarTestsOverride ? "property 'sonar.tests', '$sonarTestsOverride'" : ""
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        sonar {
            properties {
                $sonarSourcesProperty
                $sonarTestsProperty
            }
        }
        """

        when:
        var arguments = ['sonar', '--info',
                         '-Dsonar.gradle.scanAll=true',
                         '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath()]
        def result = GradleRunner.create()
          .withGradleVersion(gradleVersion)
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withArguments(arguments.stream().filter { it != null }.toList())
          .withPluginClasspath()
          .build()

        then:
        result.task(":sonar").outcome == SUCCESS

        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.gradle.scanAll" == "true"
        result.output.contains("Parameter sonar.gradle.scanAll is enabled. The scanner will attempt to collect additional sources.")
        result.output.contains("Parameter sonar.gradle.scanAll is enabled but the scanner will not collect additional sources because sonar.sources or sonar.tests has been overridden.")

        where:
        sonarSourcesOverride | sonarTestsOverride
        "src"                | null
        null                 | "test"
        "src"                | "test"
    }

    def "scan all excludes coverage report files"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """
        def extraEmptyScriptThatShouldBeCollected = projectDir.resolve("empty-script.groovy")
        def firstCoverageReport = projectDir.resolve("my-first-coverage-report.xml")
        def secondCoverageReport = projectDir.resolve("my-second-coverage-report.xml")
        def thirdCoverageReport = projectDir.resolve("my-third-coverage-report.xml")
        Files.createFile(extraEmptyScriptThatShouldBeCollected)
        Files.createFile(firstCoverageReport)
        Files.createFile(secondCoverageReport)
        Files.createFile(thirdCoverageReport)

        when:
        def result = GradleRunner.create()
                .withGradleVersion(gradleVersion)
                .withProjectDir(projectDir.toFile())
                .forwardOutput()
                .withArguments('sonar', '--info',
                        '-Dsonar.gradle.scanAll=true',
                        '-Dsonar.coverageReportPaths=my-first-coverage-report.xml,my-second-coverage-report.xml',
                        '-Dsonar.coverage.jacoco.xmlReportPaths=' + thirdCoverageReport.toRealPath().toString(),
                        '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
                .withPluginClasspath()
                .withDebug(true)
                .build()
        print("Hello")
        then:
        result.task(":sonar").outcome == SUCCESS

        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.gradle.scanAll" == "true"
        props."sonar.coverageReportPaths" == "my-first-coverage-report.xml,my-second-coverage-report.xml"
        props."sonar.coverage.jacoco.xmlReportPaths" == thirdCoverageReport.toRealPath().toString()
        result.output.contains("Parameter sonar.gradle.scanAll is enabled. The scanner will attempt to collect additional sources.")

        // Assert that the extra files (empty script and reports) exist on disk
        Files.exists(extraEmptyScriptThatShouldBeCollected)
        Files.exists(firstCoverageReport)
        Files.exists(secondCoverageReport)
        Files.exists(thirdCoverageReport)

        // Test that the empty script is is collected but the reports are not collected
        var mainSources = ((String) props."sonar.sources").split(",")
        mainSources.size() == 4
        var projectPath = projectDir.toFile().getCanonicalPath() + File.separator
        mainSources[0].endsWith("""${projectPath}build.gradle""")
        mainSources[1].endsWith("""${projectPath}empty-script.groovy""")
        mainSources[2].endsWith("""${projectPath}gradle.properties""")
        mainSources[3].endsWith("""${projectPath}settings.gradle""")

        var testSources = ((String) props."sonar.tests").split(",")
        testSources.size() == 2
        testSources[0].endsWith("""${projectPath}integrationTests${File.separator}run-all.sh""")
        testSources[1].endsWith("""${projectPath}test-license.sh""")
    }

    def "sonar task fails when failing to reach the server"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
                .withProjectDir(projectDir.toFile())
                .forwardOutput()
                .withArguments('sonar', '-Dsonar.host.url=http://localhost:0', '--info')
                .withPluginClasspath()
                .buildAndFail()

        then:
        assert result.task(":sonar").getOutcome() == TaskOutcome.FAILED
        assert result.getOutput().contains("Failed to query server version: Call to URL [http://localhost:0/api/v2/analysis/version] failed")
    }

    def "keep default sonar.region"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withEnvironment(Map.of())
          .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build();

        then:
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.host.url" == 'https://sonarcloud.io'
        props."sonar.scanner.apiBaseUrl" == 'https://api.sonarcloud.io'
    }

    def "set sonar.region to us"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withEnvironment(Map.of())
          .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath(), '-Dsonar.region=us')
          .withPluginClasspath()
          .build();

        then:
        def props = new Properties()
        props.load(outFile.newDataInputStream())
        props."sonar.region" == 'us'
        props."sonar.host.url" == 'https://sonarqube.us'
        props."sonar.scanner.apiBaseUrl" == 'https://api.sonarqube.us'
    }

    def "invalid sonar.region"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .forwardOutput()
          .withEnvironment(Map.of())
          .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath(), '-Dsonar.region=invalid')
          .withPluginClasspath()
          .buildAndFail();

        then:
        assert result.task(":sonar").getOutcome() == TaskOutcome.FAILED
        assert result.getOutput().contains("Invalid region 'invalid'.")
    }

    // FIXME get rid of this
    def "An artificial test runs in debug mode to increase coverage and merge SCANGRADLE-247"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """

        when:
        def result = GradleRunner.create()
                .withGradleVersion(gradleVersion)
                .withProjectDir(projectDir.toFile())
                .forwardOutput()
                .withArguments('sonar', '--debug', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
                .withPluginClasspath()
                .build()

        then:
        assert result.task(":sonar").getOutcome() == TaskOutcome.SUCCESS
    }

    def "clean sonar does not fail on a clean project"() {
        given:
        settingsFile << "rootProject.name = 'java-task-toolchains'"
        buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        """
        assert !projectDir.resolve("build").resolve("sonar-resolver").resolve("properties").toFile().exists()

        when:
        def result = GradleRunner.create()
          .withProjectDir(projectDir.toFile())
          .withGradleVersion("9.1.0")
          .forwardOutput()
          .withArguments('clean', 'sonar',  '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
          .withPluginClasspath()
          .build()

        then:
        assert result.task(":clean").getOutcome() == SUCCESS
        assert result.task(":sonar").getOutcome() == SUCCESS
    }

  def "multi module gradle project"() {
    given:
    def multiModuleProjectDir = projectDir("gradle-multimodule")
    // skip jacoco execution due to lock conflict on "build/jacoco/test.exec" when executing on windows
    if (!System.getProperty("os.name").toLowerCase().contains("windows")) {
      configureJacocoGradleTestkitPlugin(multiModuleProjectDir);
    }


    when:
    // Note that this test uses the current Gradle version instead of the one defined in gradleVersion.
    // This is because there seem to be a bug with older versions of Gradle TestKit when dealing with multi-module projects.
    // Older versions need to be tested using end-to-end tests (in the `integrationTests` module).
    def result = GradleRunner.create()
      .withProjectDir(multiModuleProjectDir.toFile())
      .forwardOutput()
      .withArguments('clean', 'build', 'sonar',  '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath())
      .withPluginClasspath()
      .build()

    then:
    def sonarResolver = multiModuleProjectDir.resolve("module-1/build/sonar-resolver")
    assert result.task(":sonar").getOutcome() == SUCCESS
    assert Files.list(sonarResolver).count() == 0

  }

   def "check sonar and sonarResolver are not up to date"() {
     given:
     settingsFile << "rootProject.name = 'java-task-toolchains'"
     buildFile << """
        plugins {
            id 'org.sonarqube'
            id 'java'
        }
        """

     when:
     def command = GradleRunner.create()
       .withProjectDir(projectDir.toFile())
       .forwardOutput()
       .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath(), '--info')
       .withPluginClasspath()

     def run1 = command.build()
     def run2 = command.build()

     then:
     assert run1.task(":sonar").getOutcome() == SUCCESS
     assert run2.task(":sonar").getOutcome() == SUCCESS
     assert run2.getOutput().contains("':sonarResolver' is not up-to-date")
     assert run2.getOutput().contains("':sonar' is not up-to-date")
   }

  private Path projectDir(String project) {
    return Path.of(this.class.getResource("/projects/"+project).toURI());
  }

  // some analyzer accept and expand path containing wildcards, they must not be removed
  def "path containing wildcards are not removed"() {
    given:
    var sonarSourcesProperty = "property 'sonar.sources', '$mainSources'"
    var sonarTestsProperty = "property 'sonar.tests', '$testSource'"
    var sonarJavaJdkHomeProperty = "property 'sonar.java.jdkHome', '$javaJdkHome'"
    var sonarJavaBinariesProperty = "property 'sonar.java.binaries', '$javaBinaries'"
    var sonarJavaLibrariesProperty = "property 'sonar.java.libraries', '$javaLibraries'"
    var sonarJavaTestBinariesProperty = "property 'sonar.java.test.binaries', '$javaTestBinaries'"
    var sonarJavaTestLibrariesProperty = "property 'sonar.java.test.libraries', '$javaTestLibraries'"
    var sonarLibrariesProperty = "property 'sonar.libraries', '$libraries'"
    var sonarGroovyBinariesProperty = "property 'sonar.groovy.binaries', '$groovyBinaries'"
    var sonarKotlinGradleProjectRootProperty = "property 'sonar.kotlin.gradle.project.root', '$kotlinGradleProjectRoot'"
    var sonarJunitReportPathsProperty = "property 'sonar.junit.reportPaths', '$junitReportPaths'"
    var sonarJunitReportsPathProperty = "property 'sonar.junit.reportsPath', '$junitReportsPath'"
    var sonarSurefireReportsPathProperty = "property 'sonar.surefire.reportsPath', '$surefireReportsPath'"
    var sonarJacocoXmlReportPathsProperty = "property 'sonar.coverage.jacoco.xmlReportPaths', '$jacocoXmlReportPaths'"
    var sonarAndroidLintReportPathsProperty = "property 'sonar.android.lint.reportPaths', '$androidLintReportPaths'"
    settingsFile << "rootProject.name = 'java-task-toolchains'"
    buildFile << """
        plugins {
            id 'java'
            id 'org.sonarqube'
        }
        
        sonar {
            properties {
                $sonarSourcesProperty
                $sonarTestsProperty
                $sonarJavaJdkHomeProperty
                $sonarJavaBinariesProperty
                $sonarJavaLibrariesProperty
                $sonarJavaTestBinariesProperty
                $sonarJavaTestLibrariesProperty
                $sonarLibrariesProperty
                $sonarGroovyBinariesProperty
                $sonarKotlinGradleProjectRootProperty
                $sonarJunitReportPathsProperty
                $sonarJunitReportsPathProperty
                $sonarSurefireReportsPathProperty
                $sonarJacocoXmlReportPathsProperty
                $sonarAndroidLintReportPathsProperty
            }
        }
        """

    when:
    def result = GradleRunner.create()
      .withProjectDir(projectDir.toFile())
      .forwardOutput()
      .withArguments('sonar', '-Dsonar.scanner.internal.dumpToFile=' + outFile.toAbsolutePath(), "--stacktrace")
      .withPluginClasspath()
      .build()

    then:
    result.task(":sonar").outcome == SUCCESS

    def props = new Properties()
    props.load(outFile.newDataInputStream())
    props."sonar.java.jdkHome" == javaJdkHome
    props."sonar.java.binaries" == javaBinaries
    props."sonar.java.libraries" == javaLibraries
    props."sonar.java.test.binaries" == javaTestBinaries
    props."sonar.java.test.libraries" == javaTestLibraries
    props."sonar.libraries" == libraries
    props."sonar.groovy.binaries" == groovyBinaries
    props."sonar.kotlin.gradle.project.root" == kotlinGradleProjectRoot
    props."sonar.junit.reportPaths" == junitReportPaths
    props."sonar.junit.reportsPath" == junitReportsPath
    props."sonar.surefire.reportsPath" == surefireReportsPath
    props."sonar.coverage.jacoco.xmlReportPaths" == jacocoXmlReportPaths
    props."sonar.android.lint.reportPaths" == androidLintReportPaths

    where:
    // first test path that do not exists
    // second test wildcard values and invalid values
    mainSources | testSource  | javaJdkHome | javaBinaries | javaLibraries | javaTestBinaries | javaTestLibraries | libraries | groovyBinaries | kotlinGradleProjectRoot | junitReportPaths | junitReportsPath | surefireReportsPath | jacocoXmlReportPaths | androidLintReportPaths
    "source/*/" | "**/tests"  | "jdkH?/"    | "*?.*.*/"    | "*?.*.*/"     | "*?.*.*/,**/?"   | "*?.*.*/"         | "*?.*.*/" | "*?.*.*/"      | "*?.*.*/"               | "*?.*.*/"        | "*?.*.*/"        | "*?.*.*/"           | "*?.*.*/"            | "*?.*.*/"
  }

  def boolean isGradle7OrLower(String version) {
      def major = version.substring(0, version.indexOf('.')).toInteger()
      return major <= 7
  }
}

